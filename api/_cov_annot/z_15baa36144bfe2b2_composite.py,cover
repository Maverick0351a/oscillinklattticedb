> import numpy as np
> from typing import List, Tuple, Optional
  
> from .lattice import edge_hash as _edge_hash
  
  
> def _build_mutual_knn(X: np.ndarray, k: int) -> np.ndarray:
>     n = X.shape[0]
>     if n <= 1:
!         return np.zeros((0, 2), dtype=np.int32)
>     sims = X @ X.T
>     np.fill_diagonal(sims, -1.0)
>     k_eff = min(k, max(1, n - 1))
>     nbrs = np.argsort(-sims, axis=1)[:, :k_eff]
>     edges = set()
>     for i in range(n):
>         for j in nbrs[i]:
>             if i == j:
!                 continue
>             if i in nbrs[j]:
>                 a, b = (i, j) if i < j else (j, i)
>                 edges.add((a, b))
>     if not edges:
!         return np.zeros((0, 2), dtype=np.int32)
>     return np.array(sorted(list(edges)), dtype=np.int32)
  
  
> def _laplacian_matvec_and_diag(y: np.ndarray, edges: np.ndarray):
>     n = y.shape[0]
>     if edges.size == 0 or n == 0:
!         return np.zeros_like(y), np.zeros((n,), dtype=y.dtype)
>     i = edges[:, 0]
>     j = edges[:, 1]
>     deg = np.zeros((n,), dtype=np.int32)
>     np.add.at(deg, i, 1)
>     np.add.at(deg, j, 1)
>     Ly = np.zeros_like(y)
>     dif = y[i] - y[j]
>     np.add.at(Ly, i, dif)
>     np.add.at(Ly, j, -dif)
>     return Ly, deg.astype(y.dtype)
  
  
> def _jacobi_cg(matvec, diag: np.ndarray, b: np.ndarray, x0: np.ndarray, tol=1e-5, max_iter=256):
>     x = x0.copy()
>     r = b - matvec(x)
>     Minv = 1.0 / (diag + 1e-12)
>     z = Minv * r
>     p = z.copy()
>     rz_old = float((r * z).sum())
>     res_norm = float(np.linalg.norm(r))
>     if res_norm <= tol:
!         return x, 0, res_norm
>     k = 0
>     while k < max_iter and res_norm > tol:
>         Ap = matvec(p)
>         alpha = rz_old / float((p * Ap).sum() + 1e-12)
>         x += alpha * p
>         r -= alpha * Ap
>         res_norm = float(np.linalg.norm(r))
>         if res_norm <= tol:
>             k += 1
>             break
>         z = Minv * r
>         rz_new = float((r * z).sum())
>         beta = rz_new / (rz_old + 1e-12)
>         p = z + beta * p
>         rz_old = rz_new
>         k += 1
>     return x, k, res_norm
  
  
> def _energy(U: np.ndarray, X: np.ndarray, edges: np.ndarray, lamG: float, lamC: float, lamQ: float, b: np.ndarray, q: np.ndarray) -> float:
>     term_G = 0.5 * lamG * float(((U - X) ** 2).sum())
>     if edges.size == 0:
!         term_C = 0.0
>     else:
>         dif = U[edges[:, 0]] - U[edges[:, 1]]
>         term_C = 0.5 * lamC * float((dif ** 2).sum())
>     dq = U - q[None, :]
>     term_Q = 0.5 * lamQ * float(((dq ** 2) * b[:, None]).sum())
>     return term_G + term_C + term_Q
  
  
> def composite_settle(
>     centroids: np.ndarray,
>     selected_idx: List[int],
>     q_vec: Optional[np.ndarray] = None,
>     k: int = 4,
>     lambda_G: float = 1.0,
>     lambda_C: float = 0.5,
>     lambda_Q: float = 4.0,
>     tol: float = 1e-5,
>     max_iter: int = 256,
> ) -> Tuple[float, int, float, str]:
>     """SPD-based composite settle over selected centroids.
  
>     Returns (deltaH_total, iters, final_residual, edge_hash_composite).
>     """
>     if len(selected_idx) == 0:
>         return 0.0, 0, 0.0, _edge_hash(np.zeros((0, 2), dtype=np.int32))
>     C = centroids[selected_idx]
>     if C.shape[0] == 1:
          # No edges possible
>         return 0.0, 0, 0.0, _edge_hash(np.zeros((0, 2), dtype=np.int32))
  
      # Normalize rows
>     C = C.astype(np.float32)
>     C /= (np.linalg.norm(C, axis=1, keepdims=True) + 1e-9)
>     E = _build_mutual_knn(C, k=k)
  
>     if q_vec is None:
>         q = C.mean(axis=0)
!     else:
!         q = q_vec.astype(np.float32)
>     q /= (np.linalg.norm(q) + 1e-9)
  
      # Simple pinning: top-10% by cosine to q
>     sims = C @ q
>     anchors = int(max(1, round(0.1 * C.shape[0])))
>     order = np.argsort(-sims)
>     b = np.zeros((C.shape[0],), dtype=np.float32)
>     b[order[:anchors]] = 1.0
  
>     def matvec_all(U: np.ndarray) -> np.ndarray:
>         LU, _ = _laplacian_matvec_and_diag(U, E)
>         return lambda_G * U + lambda_C * LU + lambda_Q * (b[:, None] * U)
  
>     _, deg = _laplacian_matvec_and_diag(np.zeros_like(C), E)
>     diagM = lambda_G + lambda_C * deg + lambda_Q * b
  
>     U = np.zeros_like(C)
>     max_k = 0
>     last_res = 0.0
>     for j in range(C.shape[1]):
>         rhs = lambda_G * C[:, j] + lambda_Q * (b * q[j])
>         x0 = C[:, j]
  
>         def mv_1d(xv: np.ndarray) -> np.ndarray:
>             return matvec_all(xv[:, None])[:, 0]
  
>         sol, iters, res = _jacobi_cg(mv_1d, diagM, rhs, x0, tol=tol, max_iter=max_iter)
>         U[:, j] = sol
>         max_k = max(max_k, iters)
>         last_res = max(last_res, res)
  
>     dH = _energy(C, C, E, lambda_G, lambda_C, lambda_Q, b, q) - _energy(U, C, E, lambda_G, lambda_C, lambda_Q, b, q)
>     dH = float(max(0.0, dH))
>     return dH, int(max_k), float(last_res), _edge_hash(E)
